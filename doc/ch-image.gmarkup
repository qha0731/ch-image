\markup-metadata{
\copyright{Copyright 2006, Cyrus Harmon. All Rights Reserved.}
\title{Image Processing in Common Lisp with ch-image}
\author{Cyrus L. Harmon}
\bibtex-database{(:file "lisp.bib")}
\bibtex-style{science}
}
\html-metadata{
\htmlcss{simple.css}
}

* Abstract

ch-image is an open-source Common Lisp library for image
representation, processing and manipulation. Along with companion
packages ch-imageio and clem, ch-image enables common lisp programmers
to read and write images in a number of different formats, and to
represent images in a variety of different formats, including integers
and floating point numbers of various sizes and even complex
numbers. Furthermore, ch-image provides image processing features such
as applying affine transformations, interpolation of transformed
images, and discrete convolution and morphological operations on
images.

* Introduction

Common Lisp\bibcite{steele1990common} is a high-level, compiled
language with a long history that has been used for many diverse
tasks, including artificial intelligence, computer aided design and
drafting, mathematical computation, and scientific programming. One
common complaint about common lisp is the lack of publicly available
libraries for a wide variety of tasks. In the past few years, projects
such as common-lisp.net\bibcite{common-lisp-dot-net}, the Common Lisp
Gardereners\bibcite{common-lisp-gardeners}, and The Common Lisp Open
Code Collection (CLOCC)\bibcite{clocc} have been developed to address
this lack of publicly available libraries. Image representation and
manipulation is an important, or central, part of many computing
tasks, but there remains a dearth of feature-rich, efficient, publicly
available image-processing libraries. ch-image is an open-source
common lisp library for image processing and manipulation and is
licensed under a liberal BSD-style license. ch-image uses the clem
common-lisp matrix package which provides for efficient representation
and access to typed common lisp arrays and for basic matrix operations
such as matrix arithmetic and affine transformations.

* ch-image Image Representation and Data Structures

In ch-image, image data is generally stored in one or a set of
matrices. The convention of the clem matrix package is to store matrix
data in row-major order. For ch-image, I have chosen to continue to
follow this convention, so image data is generally refered to in [y,x]
coordinates, rather than [x,y] coordinates.

Images are stored as instances of class \code{image}, described
below. Pixel intensities are values in underlying matrices. In theory
these matrices could be anything, currently they are all clem matrix
instances, of various types.

** image

The fundamental image class is an \code{image}, which is defined by the
following class definition:

\lisp-no-eval{
(defclass image ()
  ((data :accessor image-data)
   (height :accessor image-height :initarg :height)
   (width :accessor image-width :initarg :width)
   (channels :accessor image-channels :initform 1)
   (clip-region :accessor clip-region :initarg :clip-region))
  (:documentation "abstract image class"))
}

The exported accessors for the image class are \code{image-data},
\code{image-height}, \code{image-width}. The channels slot provides
for possible future dynamic image channels, but is currently
unused. The clip-region is currrently only used by the shape drawing
library. The notion of a single clip-region per image is probably too
limited and there should probably be something like an image context
on which shapes are drawn, but this currently does not exist.

*** RGB and ARGB images

RGB and ARGB images use three and four channels, respectively, to
store Red, Green, Blue color intensities and ,in the case of ARGB
images, Alpha channel information. Currently, 8-bit and 16-bit
per channel per pixel images are supported, via tha rgb-888-image
and rgb-hhh-image, for 16-bit per channel per pixel images, and
the corresponding argb image classes.

*** Grayscale Images

The class \code{gray-image} is the parent class for
representations of grayscale images. Currently, all grayscale
images are represented by subclasses of matrix-gray-image, which
in turn subclasses both gray-image and matrix. Integer valued
grayscale images are represented by the \code{ub8-},
\code{ub16-}, and \code{ub32-matrix-image} classes for unsigned
integer valued images and sb8, sb16, and sb32-matrix-image
classes for signed integer valued
images. \code{single-float-matrix-image} and
\code{double-float-matrix-image} are used to represent images with
floating point values. Finally, 

** Channels

Images have one or more channels that contain pixel value
information. In the case of RGB and ARGB images, there are 3 and 4
channels, respectively. Multi-channel images can be subclasses of the
multichannel-image class to indicate that they have multiple
channels. The generic function \code{get-channels} is used to return a
list of the channels used by an image.

Grayscale images have a single channel. matrix-gray-images subclass
both gray-image and matrix and act as their own image-data. The
\code{get-channels} method of a matrix-gray-image, returns a list
containing a single item, the matrix-gray-image itself. It may seem
counter-intuitive to return an image as it's own channel, but it
simplifies use of the image as a matrix.

The generic function \code{set-channels} is used to set the channels
of an image. In the case of matrix-gray-image, Calling set-channels
causes the underlying matrix storage to point to the specified
data. FIXME! THIS NEEDS MORE DOCUMENTATION!

** Pixels

Pixel intensity values are stored in channels as discussed
above. The generic function \code{get-pixel} returns the pixel values
for an a given row and column of an image. The actual return values
varies depending on the type of the image. For a multichannel image,
\code{get-pixel} returns a list of the intensites in the channels,
while for a grayscale image it returns the pixel intensity as a single
numerical value.

* Image Processing Functions

** Affine Transformation

The function \code{affine-transform-image} copies applies an affine
transformation to a copy of an image. Note that the original image is
unchanged and that a suitably transformed copy is return. The affine
transformation is specified by an instance of the class
\code{clem:affine-transformation}. The coordinates in pixel space of
the source and destination matrices can also be specified via keyword
arguments to \code{affine-transform-image}.

*** Interpolation

When applying an affine transformation to an image, pixels in the
source image will, in general, not map directly to pixels in the
destination image. Rather, the pixels will map to possibly non-integer
positions in the destination image. The images represented by ch-image
are all discrete images with values at integer pixels. Therefore, a
mapping from the computed, but not necessarily integral, source
destination to the proper pixel must be performed by
interpolation. ch-image provides three forms of interpolation, nearest
neighbor, bilinear interpolation, and quadratic (or bicubic)
interpolation. Quadratic interpolation will give the best results but
is the slowest. Nearest-neighbor is the least accurate, but is the
fastest. Bi-linear interpolation is a good compromise and is fairly
fast and usually yeilds acceptable results.

** Discrete Convolution

*** Gaussian Blur

*** Sharpen

*** Unsharp Mask

*** Gamma Curves

*** Image Masking

** Morphological Operations

*** Dilate

*** Erode

** Fast Fourier Transform

The Fast Fourier Transform of images is provided using a
Foreign-function Interface (FFI) to the FFTW (Fastest Fourier
Transfrom in the West) library\bibcite{frigo98fftw}. A number of
utility functions are provided to convert between the ch-image image
representation of fftw matrix represenations and to make images of the
magnitude and frequency of transformed images, and to reconstruct
spatial-domain images from magnitude and frequency images.

** Image Copying and Conversion

* Shape Drawing Primitives

** Lines

** Circles

** Rectangles

** Triangles

** Polygons

* ch-imageio

In order to get images in and out of ch-image, I/O routines are
needed. An initial set of I/O routines are provided by the ch-imageio
package. Reading and writing images are supported to and from the JPEG
and TIFF formats. There is limited PNG, but only for writing images,
which, while still limitied, means that ch-image can be used to make
PNG files for use in serving HTML content.

The read-image-file function in the ch-imageio package locates an
image file, determines it's type based on the file type (or
extension in non-lisp parlance), and creates an image of the
appropriate type (argb or greyscale, and, in theory, of the
appropriate number of bits, although at this point only 8-bit images
are supported by the IO routines.

* Using the ch-image and ch-imageio APIs

** Example 1 - Creating an Image

First, lets make an image 200 pixels high and 300 pixels wide. Then we
will draw a blue background, and a yellow triangle on the blue
background.

\lisp{
(defparameter *dark-blue* '(255 5 5 80))

(defun ch-image-example-1 ()
  (let* ((height 200)
         (width 300)
         (img (make-instance 'ch-image:argb-8888-image :height height
                             :width width))
         (image-pathname
          (make-pathname :directory '(:relative "output-images")
                         :name "example1"
                         :type "jpg")))
    (ch-image::fill-rectangle img 0 0 (1- height) (1- width) *dark-blue*)
    (ch-image::draw-triangle img 10 100 50 250 160 70 (list 255 255 255 20))
    (ensure-directories-exist image-pathname)
    (ch-imageio:write-image-file image-pathname img)))

(defparameter *example-image-1* (ch-image-example-1))
}

This gives us the following image:

\image{\lisp-value{*example-image-1*}}

** Example 2 - Loading an Image from a JPEG File

We use read-image-file to load a sample image of the San
Francisco skyline:

Here's the original image:

\image{images/sanfran.jpg}

\lisp{(defparameter *sanfran*
  (ch-imageio:read-image-file
   (make-pathname :directory '(:relative "images")
                  :name "sanfran"
                  :type "jpg")))
}

** Example 3 - Convert Image to Grayscale and Write PNG File
 
The following code will convert the image to a grayscale image and
write it out as a PNG file:

\lisp{(defparameter *sanfran-png-file*
  (ch-imageio:write-image-file
   (make-pathname :directory '(:relative "output-images")
                  :name "sanfran"
                  :type "png")
   (ch-image:argb-image-to-gray-image *sanfran*)))
}

\image{\lisp-value{*sanfran-png-file*}}

** Example 4 - Applying a gamma curve

\lisp{
(defparameter *sanfran-lighter-image*
  (ch-image::apply-gamma *sanfran* 0.60d0))

(defparameter *sanfran-lighter-file*
  (ch-imageio:write-image-file
   (make-pathname :directory '(:relative "output-images")
                  :name "sanfran-lighter"
                  :type "jpg")
   *sanfran-lighter-image*))
}

\image{\lisp-value{*sanfran-lighter-file*}}

* ch-image API reference

* Installing ch-image and required packages

\bibliography{}
